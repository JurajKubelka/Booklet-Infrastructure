!! Commander: A command pattern library

In this chapter you will learn about a new library to manage commands. The library is based on three main objects: ''commands'' that represent the actions to be executed, ''command activation strategies'' that represent ways commands are activated (i.e., using shortcuts, menus..) and ''contexts'' which represent the state of application, users of commands.

!!! Commands

Commander models application actions as first class objects following the Command design pattern.
Every action is implemented as separate command class (subclass of ==CmdCommand==) with the ==execute== method and all state required for execution.

!!! An example

Let's look how we can apply commands to control simple contact book.
The code of example is packaged inside Commander-Examples package. So you can load it and play.

In our domain we need two classes one for the contact and one for the contact book.

!!!! 1. Contact with name and phone

[[[
Object subclass: #Contact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
Contact >> printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	aStream nextPutAll: name.
	aStream nextPut: $).
]]]

!!!! 2. Contact book: a collection of contacts

[[[
Object subclass: #ContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
ContactBook >> addContact: aContact
	contents add: aContact
]]]

[[[
ContactBook >> add: contactName phone: phone
	| contact |
	contact := CmdContact named: contactName phone: phone.
	self addContact: contact.
	^contact
]]]

[[[
ContactBook >> includesContact: aContact
	^ contents includes: aContact
]]]

!!!! 3. A first command
Now we can create ==RenameContactCommand== to rename given contact

[[[
CmdCommand subclass: #RenameContactCommand
	instanceVariableNames: 'contact newName'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
RenameContactCommand >> execute
	contact name: newName
]]]

We need accessors and constructors for all these classes. For example for the command it would be:

[[[
RenameContactCommand class >> contact: aContact to: newNameString
	^self new
			contact: aContact;
			newName: newNameString
]]]

And in playground we are able rename contact using this command:

[[[
| contact command |
contact := Contact new.
command := RenameContactCommand contact: contact newName: 'John Smith'.
command execute.
]]]

!!! Adding a simple UI

Before we continue we should write simple UI which will show contact book contents.
You should be fimilar with Spec UI framework to follow this example.

We need just one presenter which will show contact table

[[[
ComposablePresenter subclass: #ContactBookPresenter
	instanceVariableNames: 'table contactBook'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
ContactBookPresenter >> initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name. contact phone} ].
	table items: contactBook contents
]]]

Also let's define a reusable book as class side variable

[[[
ContactBook >> family
	^family ifNil: [
		family := self new
			add: 'John' phone: '342 345';
			add: 'Bill' phone: '123 678';
			add: 'Marry' phone: '789 567';
			yourself ]
]]]

Now we are able show family phone book with Spec UI:

[[[
ContactBookPresenter class >> familyExample
	<example>
	^ (self on: ContactBook family) openWithSpec
]]]

We put it as example. So you can run it from the browser using suitable icon:

%+Family book window.>file://Figures/Family.png+
%+Family book window.>file://figures/Family.png|label=Family+

!!! Activation strategy

Commands are reusable objects and applications provide various ways to access them: shortcuts, context menu, buttons, etc.
This information is attached to command classes as activation strategies. Currently there are three types of activations:
- ==CmdShortcutCommandActivation==
- ==CmdContextMenuCommandActivation==
- ==CmdDragAndDropCommandActivation==

Strategies annotate command as contextual class annotations. Look at the project ClassAnnotation for details *https://github.com/dionisiydk/ClassAnnotation*. 

Strategies are always attached to commands with concrete application context where they can be used.
In the simplest case, it can be just a class of user application or widget like the class ==ContactBookPresenter==.

For example the following method allows an instance of ==RenameContactCommand== to be executed by shortcut in the context of our presenter:

[[[
RenameContactCommand class >> shortcutActivation
	<classAnnotation>
	^ CmdShortcutCommandActivation by: $r meta for: ContactBookPresenter
]]]

Similarly the following method ==menuActivation== defines that the ==RenameContactCommand== can be executed from a context menu. Note the use of ==CmdContextMenuCommandActivation== in the method, while the previous one was using ==CmdShortcutCommandActivation==.

[[[
RenameContactCommand class >> menuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: ContactBookPresenter
]]]


!!!! Set the presenter

Now when you open window neither shortcuts or context menu will work. The problem is that Spec has no information about Commander. Spec only provides basic functionality to define menu and shortcuts on low level. So you should manually activate Commander in your Spec presenter.

Modify ==initializeWidgets== method to activate context menu:

[[[
ContactBookPresenter >> initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name . contact phone} ].
	table items: contactBook contents
	table enableCommanderMenuBy: self
]]]

===enableCommanderMenuBy:=== adds context menu to table presenter which will be filled by commands defined in context of presenter in the argument (==ContactBookPresenter==).

In this case the right click on table will show the menu with single item named ==RenameContactCommand==.
To specify better name for menu, you need to define the method ==defaultMenuItemName==:

[[[
RenameContactCommand >> defaultMenuItemName
	^'Rename'
]]]

!!! Getting the information from the user

Now if you will click on 'Rename' menu item you will get an exception. From the debugger you can investigate that command instance is not initialized: ==contact== and ==newName== are nil.
Commander provides method where command should retrieve required state from given context instance:

[[[
RenameContactCommand >> prepareExecutionInContext: aToolContext
	super prepareExecutionInContext: aToolContext.

	contact := aToolContext selectedContact.

	newName := UIManager default
		request: 'New name of the contact'
		initialAnswer: contact name
		title: 'Rename a contact'.
	newName isEmptyOrNil | (newName = contact name) ifTrue: [ ^ CmdCommandAborted signal ]
]]]

By default (with help of Spec integration) Commander will pass presenter instance to aToolContext argument. But in general it is not enough and you will see example later.

Now you only need to know that context represents application state and in ==prepare== method we define what information is required to be able reuse commands in various applications.

In our example we expect to receive ==selectedContact== from the context. And we request ==newName== directly from user.
Notice that Commander provides way how to define specific preparation method for specific application context. By default it is ==prepareExecutionInContext:== but it can be different for advanced scenarios.

So we need ==selectedContact== for presenter to make it compatible to context of our command:

[[[
ContactBookPresenter >> selectedContact
	^ table selectedItem
]]]

Now if you will click on 'Rename' item you will be requested for new contact name. But after submit the view will be not updated. Reopen presenter window to see the result.

!!!! Refreshing the view

It is your responsibility to manage updates between application and model. You can use some event mechanism which will automatically udpate view after modification of model.

But Commander provides very simple way to apply result of command which can be also used to update the view.

==applyResultInContext:== is called when command is executed. You can implement it on your commands to produce desired effect in context of your application:

[[[
RenameContactCommand>>applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView
]]]

Here we require that context should be able update the view. And presenter should support it:

[[[
ContactBookPresenter >> updateView
	table items: contactBook contents
]]]

Finally context menu item is working fine: it asks new name and table updates after submit.


!!!! Enabling shorcuts

Now we can enable shortcuts on the presenter. Just implement method ==ensureKeyBindingsFor:==:

[[[
ContactBookPresenter >> ensureKeyBindingsFor: aWidget
	self enableCommanderShortcutsIn: aWidget
]]]

Then reopen window, select contact and press cmd+r (on Mac). You will get same UI dialog as in case of menu.



!!! Adding more commands

At the end try create few other commands. With ready infrastructure in presenter the creation of new commands is very straightforward process:
!!!! 1. Command to modify contact phone number:

[[[
CmdCommand subclass: #ChangePhoneCommand
	instanceVariableNames: 'contact newPhone'
	classVariableNames: ''
	package: 'Commander-Examples'

ChangePhoneCommand >> execute
	contact phone: newPhone

ChangePhoneCommand >> prepareFullExecutionInContext: aToolContext
	super prepareFullExecutionInContext: aToolContext.

	contact := aToolContext selectedContact.

	newPhone := UIManager default
		request: 'New phone for the contact'
		initialAnswer: contact phone
		title: 'Set new phone for contact'.
	newPhone isEmptyOrNil | (newPhone = contact name) ifTrue: [ ^ CmdCommandAborted signal ]

ChangePhoneCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

ChangePhoneCommand >> defaultMenuItemName
	^'New phone'
]]]

Activation methods:

[[[
ChangePhoneCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: CmdContactBookPresenter

ChangePhoneCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $p meta for: CmdContactBookPresenter
]]]

!!!! 2. Command to remove contact:

[[[
CmdCommand subclass: #RemoveContactCommand
	instanceVariableNames: 'contactBook contact'
	classVariableNames: ''
	package: 'Commander-Examples'

RemoveContactCommand >> execute
	contactBook removeContact: contact

RemoveContactCommand >> prepareFullExecutionInContext: aToolContext
	super prepareFullExecutionInContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	contact := aToolContext selectedContact.

RemoveContactCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

RemoveContactCommand >> defaultMenuItemName
	^'Remove'
]]]

Here we extend our requirement to the context: to be able remove a contact we also need a contact book instance where we should perform deletion.

And we implement new method ==selectedContactBook== in the presenter:

[[[
ContactBookPresenter >> selectedContactBook
	^contactBook
]]]

Notice that in ==prepare== method we could call accessor ==contactBook== from aToolContext. But it leads to bad reusability of command because the name ==contactBook== means single book instance while other applications can provide multiple of them in same way like our current presenter provides multiple contacts.
So in sense of tool context it is better to call ==selectedContactBook== because it is better reflects abstract requirement of information: we expect that there will be selected book in context of command activation.

Activation methods:

[[[
RemoveContactCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: CmdContactBookPresenter

RemoveContactCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $x meta for: CmdContactBookPresenter
]]]

!!!! 3. Command to add contact:

[[[
CmdCommand subclass: #AddContactCommand
	instanceVariableNames: 'contactBook contact'
	classVariableNames: ''
	package: 'Commander-Examples'

AddContactCommand >> execute
	contactBook addContact: contact

AddContactCommand >> prepareFullExecutionInContext: aToolContext
	| nameAndPhone pair |
	super prepareFullExecutionInContext: aToolContext.
	contactBook := aToolContext selectedContactBook.

	nameAndPhone := UIManager default
		request: 'Enter new contact name and phone (split by comma)'
		initialAnswer: 'name;phone'
		title: 'Create new contact'.
	nameAndPhone isEmptyOrNil ifTrue: [ ^ CmdCommandAborted signal ].
	pair := (';' split: nameAndPhone).
	contact := CmdContact named: pair first phone: pair last

AddContactCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

AddContactCommand >> defaultMenuItemName
	^'New contact'
]]]

In preparation we request user for both name and phone number in simple comma separated form.

Activation methods:

[[[
AddContactCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: CmdContactBookPresenter

AddContactCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $n meta for: CmdContactBookPresenter
]]]

%+Family book menu>file://figures/FamilyMenuDefault.png+

It is up to you to maintain commands in good shape. For example commands here use same state ==contact== and duplicate method ==applyResultInContext:==. You can refactor it with your taste, extract common superclass and so on.

!!! Extra command conditions

Now there will be error if you will try rename contact when no item is selected in table.

Normally menu should not include items in such cases or they should be disabled.

To define runtime condition where command can be activated you need class side method ==canBeExecutedInContext==:

[[[
RenameContactCommand class>>canBeExecutedInContext: aToolContext
	^aToolContext isContactSelected
]]]

(As default implementation any command can be executed in any context. So by default this message returns true)

And presenter should implement ==isContactSelected==:
[[[
ContactBookPresenter>>isContactSelected
	^table selectedItem notNil
]]]

!!! Context menu tuning

We already redefine menu item name in the method ==defaultMenuItemName==.
There are other settings:
- order of item in menu
- menu group of item
- separator between items
- menu icon
- custom menu item

!!!! Menu item order

In our example 'Rename' item was placed at the end of menu because by default items are sorted in alphabetical order.
To change the order the activation strategy should be created with extra parameter:

[[[
RenameContactCommand >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemOrder: 1 for: CmdContactBookPresenter
]]]

The lesser order value puts item to the top of menu list.

%+Context menu reordered>file://Figures/FamilyMenuRenameFirst.png+

!!!! Menu groups

Commander allows create hierarchical menu using reified menu groups.
Imaging that you want put 'New phone' command under 'Phone operations' submenu.

First you need new subclass of CmdMenuGroup:

[[[
CmdMenuGroup subclass: #PhoneMenuGroup
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

And then add this class as extra parameter to the menu activation strategy:

[[[
ChangePhoneCommand >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byItemOf: PhoneMenuGroup for: CmdContactBookPresenter
]]]

It will moves ChangePhoneCommand to extra submenu with name 'PhoneMenuGroup'. You can specify better name as in case of commands:

[[[
PhoneMenuGroup>>name
	^'Phone operations'
]]]

%+Submenu>file://Figures/FamilyMenuPhoneGroup.png+

If you need deep menu structure just define class side method ==parent== in your very child group:

[[[
DeepChildrenMenuGroup class>>parentGroup
	^PhoneMenuGroup
]]]

!!!! Menu separators

Commander uses separators to represent inlined menu groups.

If group is marked as inlined then all items are added to the parent group with required separator lines. To inline group you need override method ==isInlined==:

[[[
PhoneMenuGroup>>isInlined
	^true
]]]

%+Inlined menu>file://Figures/FamilyMenuInlined.png+

!!!! Menu icons

To specify icon the command should implement the instance side method ==setUpIconForMenuItem:==. For example we can add icon to the ==RemoveContactCommand==:

[[[
RemoveContactCommand>>setUpIconForMenuItem: aMenuItemMorph
	self setUpIconNamed: #removeIcon forMenuItem: aMenuItemMorph
]]]

%+Iconic menu item>file://Figures/FamilyMenuWithIcon.png+

As you can see it is not primitive ==icon== method which returns the icon instance.

The idea is to be able create dynamic and complex icons based on command state.

!!!! Custom menu items

When Commander builds context menu it asks command itself to build view (a morph) for menu item.
By default CmdCommand returns standard menu item morph but subclasses can redefine it to be represented specifically.

For example we can represent item with different color:

[[[
RenameContactCommand>>fillContextMenu: aMenu using: aCommandActivator
	| item |
	item := aMenu
		add: aCommandActivator menuItemName
		target: aCommandActivator
		selector: #executeCommand.

	item color: Color red
]]]

%+Custom menu item>file://Figures/FamilyMenuWithCustomItem.png+

You can notice here that command can be represented by multiple menu items. ==fillContextMenu== method provides full control under menu.
For example you can generate multiple command copies with some specific parameters. It allows highly dynamic menus which can be needed for some special applications.

Also same kind of flexibility is available for groups. Look at default implementation of menu group for example:

[[[
CmdMenuGroup>>buildContextSubMenuIn: aMenu
	| submenu |
	submenu := UIManager default newMenuIn: aMenu defaultTarget for: aMenu defaultTarget.

	contents do: [ :each | each buildContextMenu: submenu ].

	submenu hasItems ifTrue: [ aMenu add: self name subMenu: submenu]
]]]

You can redefine it in your own group to build very special menus.

!!! Drag and drop example

In this section you will learn how activate commands using drag and drop operation.

During drag and drop operation user grabs some element from one widget and drops it on another widget. And the application handles special event which brings together the information about source and target elements.

Commander uses drag and drop to prepare commands in two steps:

1) When user starts drag some element from the widget Commander finds and prepares commands in context of this widget and dragged element. Then found commands are used as passengers of drag operation.
2) When user drops element to the widget Commander filters current dragged commands using declared drop context and the context of target widget. At the end it executes found command.

If Commander does not find any commands in drag context the drag and drop operation is not started.

If Commander does not find any command suitable for drop context it forbids drop on current widget. UI gives visual feedback for the places where drop can be executed. And when drop is forbidden you will not see this effect.

If Commander finds multiple commands suitable for the drop context it will show menu to request user to choose concrete action.

Now we can annotate existing command ==AddContactCommand== with drag and drop activation:

[[[
AddContactCommand class>>dragAndDropActivation
	<classAnnotation>
	^CmdDragAndDropCommandActivation for: ContactBookPresenter toDropIn: ContactBookPresenter
]]]

First parameter describes context where drag can be started. And last parameter is a context where drop can be executed. In example both are the same presenter which enables drag and drop contacts between contact books.

As in example with context menu and shortcuts we also need activate Commander based drag and drop in our presenter. It should be enabled in ==initializeWidgets== method:

[[[
ContactBookPresenter>>initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name. contact phone} ].
	table items: contactBook contents.
	table enableCommanderMenuBy: self.

	table enableCommanderDragAndDropBy: self.
]]]

And to prepare command instance in two steps we need implement to methods:

[[[
AddContactCommand>>prepareExecutionInDragContext: aToolContext
	super prepareExecutionInDragContext: aToolContext.

	contact := aToolContext selectedContact
]]]

==prepareExecutionInDragContext== extracts information from the context of drag operation. In that case we decided that command can be only executed by drag of selected contact.

[[[
AddContactCommand>>prepareExecutionInDropContext: aToolContext
	super prepareExecutionInDropContext: aToolContext.

	contactBook := aToolContext selectedContactBook
]]]

And in second method ==prepareExecutionInDropContext== we extract the rest information from the context where the drop was executed. In that case we decided that command can be only executed by drop into the contact book.

Now drag and drop should work. To play with it let's create another book of coworkers on the class side of ==ContactBook==:

[[[
ContactBook class>>coworkers
	^coworkers ifNil: [
		coworkers := self new
			add: 'Stef' phone: '112 378';
			add: 'Pavel' phone: '898 678';
			add: 'Marcus' phone: '444 888';
			yourself]
]]]

And we need extra example method on the class side of presenter:

[[[
ContactBookPresenter class>>coworkersExample
	<example>
	^ (self on: CmdContactBook coworkers) openWithSpec
]]]

Now open two windows: ==coworkersExample== and ==familyExample==. And drag and drop contacts between them.

You can notice that you are able dublicate contact when it already exists in the target book. Also dublication happens when you drop contact in same source book.

To prevent it you can specify extra runtime condition ==canBeExecutedInDropContext:== as in case of full command execution:

[[[
AddContactCommand>>canBeExecutedInDropContext: aToolContext
	^aToolContext isContactBookSelected
		and: [ (aToolContext selectedContactBook includesContact: contact) not ]
]]]

Notice that this method is on instance side and it can use the data which was extracted from drag context. Here we check that ==contact== not exists in target contact book.

When Commander collects commands at the time of drag operation it prepares them using method ==prepareExecutionInDragContext==. So at the time of drop operation all found commands are initialized with information from drag context.

Also notice that here we add extra check ==isContactBookSelected==. We can omit it because in our example contact book always exists in presenter. But for reusability purpose we should implement this method independently from our knowledge about existing context. Imaging that we will have another presenter with table of existing books and we will need to drag contacts to it items. In that case it will be required to check that book is actually selected. Instead we will get error when table has no selection.

So at the end our presenter do not accept drops of contacts which aready exist in the book.

!!! Complex contexts

In examples command context was always represented by presenter itself. It is default behavior of Spec integration with Commander.

Problem with this approach is that presenter always bound to its own current state. It is fine for simple cases. But for example you are not able to activate our commands in context of contact which is not selected in the table. Following example demonstrates problem in live:

You can notice that dropping contact into the book always adds it to the end of list. But drop operation is always points to some element in the table. So we can support drop to the particular position.

For this we need extend ==AddContactCommand== with ==afterContact== variable after which we will add new contact:

[[[
CmdCommand subclass: #AddContactCommand
	instanceVariableNames: 'contactBook afterContact contact'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

And we should modify execution method to take into new logic. And we need extra method for ==ContactBook==:

[[[
AddContactCommand>>execute
	afterContact
		ifNil: [ contactBook addContact: contact]
		ifNotNil: [ contactBook addContact: contact after: afterContact ]

ContactBook>>addContact: newContact after: contactBefore
	contents add: newContact after: contactBefore
]]]

So if ==afterContact== is not specified the new contact will be added to the end of list.

We can support this logic in full execution scenario where command is activated from menu or by shortcut:

[[[
AddContactCommand>>prepareFullExecutionInContext: aToolContext
	| nameAndPhone pair |
	super prepareFullExecutionInContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	aToolContext isContactSelected ifTrue: [
		afterContact := aToolContext selectedContact].

	nameAndPhone := UIManager default
		request: 'Enter new contact name and phone (split by comma)'
		initialAnswer: 'name,phone'
		title: 'Create new contact'.
	nameAndPhone isEmptyOrNil ifTrue: [ ^ CmdCommandAborted signal ].
	pair := (',' split: nameAndPhone).
	contact := CmdContact named: pair first phone: pair last
]]]

New contact will be added after selected contact in context of target presenter (aToolContext is a presenter instance for now).

You can test new logic by creation new contacts from menu or by shortcuts.

For drag and drop case we should also modify ==prepareExecutionInDropContext:==:

[[[
AddContactCommand>>prepareExecutionInDropContext: aToolContext
	super prepareExecutionInDropContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	aToolContext isContactSelected ifTrue: [
		afterContact := aToolContext selectedContact].
]]]

Now if you would play with drag and drop you will notice that it works in not expected way: new contact is always added into the target book after selected item instead of the item where drop is executed.

The problem is that the selection of the drop target is the static state of the target book presenter. It could not be different depending on the actual place of drop operation.

And here we finally should introduce the real context which will incapsulate selected contact independently of presenter. This example shows that the simple case where presenter is its own context has limitations.

Contexts are subclasses of ==CmdToolContext== and they should include all information to describe the state of underlying tool. In our case it will include ==selectedContacts== variable:

[[[
CmdToolContext subclass: #ContactBookPresenterContext
	instanceVariableNames: 'selectedContacts'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

For Spec support Commander passes multiple items to request context from presenter. So we should use contact collection instead of single item. And generally it is more common case. Selection can include multiple items.

In addition context should support all methods which are required by commands:

[[[
ContactBookPresenterContext>>selectedContact
	^selectedContacts last "last selected item"

ContactBookPresenterContext>>isContactSelected
		^selectedContacts notEmpty

ContactBookPresenterContext>>selectedContactBook
		^tool contactBook

ContactBookPresenterContext>>isContactBookSelected
		^true
]]]

Notice that base class of context ==CmdToolContext== provides ==tool== variable which is presenter instance in our case.

Also to implement ==selectedContactBook== we do not need to call ==selectedContactBook== from presenter. It was the message to represent presenter as own context. So ==selectedContactBook== can be removed from presenter together with ==isContactBookSelected== method because they are now defined by reified context class.

==ContactBookPresenterContext== tightly bound to the ==ContactBookPresenter==. So it knows that contact book is mondatory property of presenter and it can call accessor directly.

To inject new context to our presenter we should override two methods:

[[[
ContactBookPresenter>>createCommandContextForSelection: selectedContacts
	^ContactBookPresenterContext for: self of: selectedContacts

ContactBookPresenter>>createCommandContext
	^self createCommandContextForSelection: table selectedItems
]]]

First method creates concrete context instance with selected items. And last method provides default selection (from table) to the context.

And there is one important thing more:

When we introduce new context the way how Commander searches commands is changed. By default (for Spec) Commander finds all commands which are annotated with given presenter class (using isKindOf: check for this). But in general case with reified context Commander scans commands using class of context instead of class of tool.

In general case activation strategies should be attached to commands using class of context instead of tool. The reason why it is implemented like this is that single application/presenter can provide multiple contexts depending on child component which triggers menu, shortcuts and so on. In general case single presenter can have many different menus. For example we can create presenter with two tables. And each table should provide own menu and shortcuts.

So if we will do nothing our example will loose all menus and shortcuts. There is two ways to fix it:

1. Modify all command activations to use context class ==ContactBookPresenterContext== instead of presenter class ==ContactBookPresenter==.

This approach would be required if we would extend our presenter with extra component which will provide separate set of commands. But in our example we do not need it.

2. Adopt our context to be simple single context of presenter.

In case when presenter provides single set of commands we can just mark the context as simple. It is preferred solution for simple presenters because in that case internal context implementation will be hidden from users. All commands will mention only presenter class in annotations.

So in simple context the tool (presenter) is actual user of commands. And it should redefine the method ==representsSimpleAnnotationUser:== by testing that the tool is a kind of given class.

In our example we follow this approach:

[[[
ContactBookPresenterContext>>representsSimpleAnnotationUser: aToolClass
	^tool isKindOf: aToolClass
]]]

Now if you will try again drag and drop you will see that drop inserts contact after element where drop is executed.

And a bit of details about this logic:
==representsSimpleAnnotationUser== method is part of ClassAnnotation library. When you create annotation using class as context the annotation will be visible only for instances of this class hierarchy. Annotation will use simple ==isKindOf:== check to detect that given user can find it. But user can redefine this logic using this method.

In case of Commander the user of annotation is a tool context. But there is ==CmdSimpleToolContext== which is default for Spec presenters. It redefines this logic in the way that the tool becomes actual user of annotation. It simply checks that the tool is a kind of declared user class. ==CmdSimpleToolContext== redefine other logic of base ==CmdToolContext==. So it should not be used as superclass.

And simple reified contexts should redefine this method in same way. And it is what we did in this example.

================todo=====================


 And at the end Commander prepare commands in context of the element which performs drop e When user starts drag something from the widget Commander finds all commands

Drag and drop command activation is different than others.
To prepare command it needs two contexts. First context describes the place where drag was started. Second context describes drop target tool.
So activator prepares command execution in both contexts. They bring different information.
And together they are supposed to provide all required data for command execution without extra user requests.

According to this logic commands should define following supporting methods when they want drag and drop:

- ==prepareExecutionInDragContext: aToolContext==
- ==prepareExecutionInDropContext: aToolContext==
- ==canBeExecutedInDropContext: aToolContext==

Also specific contexts can define own set of activation methods:


!!! Commands, activations and contexts

The commander library is structured around three main entities:

- ''commands'' that represent the actions to be executed,
- ''command activation strategies'' that represent ways commands are activated (i.e., using shortcuts, menus..) and
- ''contexts'' which represent the applications in particular state.

@@todo SD:here we should have a diagram


!!! Contexts

Activation strategies are always declared with the application context where they can be applied.
In simplest case it can be just a class of command user application (==PackageBrowser== in example).

An application should provide such contexts as subclasses of ==CmdToolContext== with information related to the  application state.

Every widget can bring its own context to interact with application as separate tool.
For example, a system browser shows multiple panes which provide package, class  and method contexts. Depending on the context, the browser will show different menus and provides different shortcuts.


To support activators, command should implement several methods: ==What is a standardContext:==?

!!!! canBeExecutedInContext: aToolContext
The method ==canBeExecutedInContext: == defines whether the command that be executed in a context. By default it returns true. But usually commands query context for specific information.

For example ==RenamePackageCommand== requires a package and it defines this method as follows:

[[[
RenamePackageCommand >> canBeExecutedInContext: aToolContext
   ^aToolContext isPackageSelected
]]]

!!!! prepareFullExecutionInContext: aToolContext
With the method ==prepareFullExecutionInContext:==, the command should retrieve all state required for execution. It can also ask user for extra data. For example ==RenamePackageCommand== retrieves the package to be renamed from the context and asks the user for new name:

[[[
RenamePackageCommand >> prepareFullExecutionInContext: aToolContext

    package := aToolContext selectedPackage.
    newName := UIManager default
        request: 'New name of the package'
        initialAnswer: package name
        title: 'Rename a package'.
    newName isEmptyOrNil | (newName = package name)
		ifTrue: [ ^ CmdCommandAborted signal ]
]]]

Note that to abort command execution, a command can raise the ==CmdCommandAborted== signal.

!!!! applyResultInContext: aToolContext
Purpose of the method ==applyResultInContext:== is to be able interact with application when command completes. ==I do not like the name of the method== why not ==afterExecution or postActionInContext:==.

For example, when a user creates new package from a browser, we want to tool to show the package. We expressed that once the command is executed, the browser should open created package as follows:

[[[
CreatePackageCommand >> applyResultInContext: aToolContext
    aToolContext showPackage: resultPackage
]]]

== SD:hy this logic is defined in the command and not in the tool logic??==



Commands are supposed to be reusable for different contexts and these methods should be implemented with that in mind. They should not leak internal structure of contexts.

!!! Specific contexts

Specific context can override activation methods and send its own set of messages to command.

 For example:

[[[
SpecialContextA >> allowsExecutionOf: aCommand
	 ^aCommand canBeExecutedInSpecialContextA: self

SpecialContextA >> prepareFullExecutionOf: aCommand
  aCommand prepareFullExecutionInSpecialContextA: self

SpecialContextA >> applyResultOf: aCommand
  aCommand applyResultInSpecialContextA: self
]]]

==I'm lost: where these methods come from? are they defined?==


By default ==CmdCommand== can implement with standard context methods. And only particular commands will override them specifically:

[[[
CmdCommand >> prepareFullExecutionInSpecialContextA: aSpecialContextA
  self prepareFullExecutionInContext: aSpecialContextA

SomeCommand >> prepareFullExecutionInSpecialContextA: aSpecialContextA
  "special logic to prepare command for execution"
]]]

The way how concrete type of activator hooks into application is responsibility of application. Look at related sections for details on concrete activator.

In future Commander will provide deep integration with UI. And many things will work automatically.

!!! Command execution

Context instances are used to perform command lookup.
For example following expression will enumerate all shortcut activators relevant to package pane of a possible browser:

[[[
CmdShortcutCommandActivator
  allDeclaredFor: aPackageBrowserContext
  do: [ :declaredActivator | show all the code here please ]
]]]

A declared activator is in fact not ready for execution because it should be bound to a context.
It should create new activator instance for this:

[[[
readyActivator := declaredActivator newActivationFor: aPackageBrowserContext
]]]

Ready activator is bound to given context and it keeps a new command instance. To execute command evaluate:

[[[
readyActivator executeCommand
]]]

Before execution, users should check that it is possible:

[[[
activator canExecuteCommandInContext: aPackageBrowserContext
]]]

There is a convenient method to enumerate only executable commands. Here is for example how to get all the executable commands for package related commands.

[[[
CmdShortcutCommandActivator
   allExecutableIn: aPackageBrowserContext
   do: [ :readyActivator |
   please show code that we can execute ]
]]]



!!! Abstract menu activation
@abstractMenuActivation


==SD:why abstract??==.

There are a lot of different types of menu: context menu, toolbar, morphic halo menu, etc.
All of them are very similar: they show set of items to the user and when user selects one the action associated with item is evaluated. The main difference between them is the way how they are represented to user and where they are shown in application.

The commander library allows the building of different kind of menus based on commands and first class groups. Concrete type of menu is represented by concrete type of activator, subclass of ==CmdMenuCommandActivator==.

These activators mark commands to be part of menu:

[[[
YourCommand >> yourAppMenuActivator
  <commandActivator>
  ^ConcreteMenuCommandActivator byItemOf: YourAppChildMenuGroup for: YourAppContext
]]]

Activator provides information about name, group and position of command inside menu:
- ==menuItemName== (by default it is retrieved from command instance by sending the message ==defaultMenuItemName==).
- ==menuItemOrder== (higher value pushes command to the end of menu)
- ==menuGroup== (root by default)

To set up these properties there are few instance creation methods:
- ==byRootGroupItemFor: YourAppContext==
- ==byRootGroupItemOrder: aNumber for: YourAppContext==
- ==byItemOf: menuGroupClass for: YourAppContext==
- ==byItemOf: menuGroupClass order: aNumber for: YourAppContext==

==CmdMenu== represents abstract tree structure for concrete menu implementation:
==SD:I do not get how cmdMenu is related to ConcreteMenuCommandActivator==
==SD: give a real example==
[[[
menu := CmdMenu activatedBy: aCommandActivatorClass
]]]

==I'm lost why do we need a commandActivatorClass here?==

It builds commands and group items using information from activators declared for given context:

[[[
menu buildInContext: aToolContext
]]]

This method can be called multiple times for different contexts. It allows one to build single menu for multiple parts of application. For example toolbar menu can include commands for all visible widgets.

Menu groups are represented by subclasses of ==CmdMenuGroup==. They are used as classes to declare activators. Instances are only created during menu building.

Groups are containers of command items and other groups. They define following methods to describe menu structure:
- ==parentGroup== on class side. By default it is CmdRootMenuGroup. Subclasses override it to define deep tree structure.
- ==order== on instance side. Larger values pushed group to the end of menu
- ==name== on instance side. It should be shown to user in concrete menu implementation.

Concrete menu activators extend menu objects and commands with specific methods to build concrete view elements. For example look at next section.

==SD: but next section refers to this one==

!!! Context menu command activation

To add commands into context menu use ==CmdContextMenuCommandActivator== (more details at *@abstractMenuActivation*). For example:

[[[
RenamePackageCommand class >> packageBrowserMenuActivator
  <commandActivator>
  ^CmdContextMenuCommandActivator byRootGroupItemFor: PackageBrowserContext
]]]

To build context menu morph use following expression:

[[[
menu := CmdContextMenuCommandActivator buildMenuFor: anAppMorph inContext: aToolContext
]]]

Context menu extends command with menu building method:

[[[
CmdCommand >> fillContextMenu: aMenu using: anActivator
]]]

It creates menu item morph and allows subclasses to define default label and icon:

- ==defaultMenuItemName==
- ==setUpIconForMenuItem: aMenuItemMorph==

Subclasses can override building method ==fillContextMenu:using:== to represent themselves differently. For example they can create menu item with check box.

!!! Shortcut command activation

To mark commands with shortcuts use CmdShortcutCommandActivator. For example:

[[[
RenamePackageCommand class >> packageBrowserShortcutActivator
  <commandActivator>
  ^CmdShortcutCommandActivator by: $r meta for: PackageBrowserContext
]]]

There are extra instance creation methods for standard shortcuts:
- ==renamingFor: aToolContext==
- ==removalFor: aToolContext==

To support shortcuts based on commands application should define specific kmDispatcher for target morphs:

[[[
YourAppMorph >> kmDispatcher
  ^CmdKMDispatcher attachedTo: self
]]]

with supporting method:

[[[
YourAppMorph >> createCommandContext
  ^YourAppContext for: self
]]]

!!! Drag and drop command activation

Drag and drop command activation is different than others.
To prepare command it needs two contexts. First context describes the place where drag was started. Second context describes drop target tool.
So activator prepares command execution in both contexts. They bring different information.
And together they are supposed to provide all required data for command execution without extra user requests.

According to this logic commands should define following supporting methods when they want drag and drop:

- ==prepareExecutionInDragContext: aToolContext==
- ==prepareExecutionInDropContext: aToolContext==
- ==canBeExecutedInDropContext: aToolContext==

Also specific contexts can define own set of activation methods:

[[[
SpecialContextA >> allowsDropExecutionOf: aCommand
  ^aCommand canBeExecutedInSpecialDropContextA: self

SpecialContextA >> prepareDragActivationOf: aCommand
	aCommand prepareExecutionInSpecialDragContextA: self

SpecialContextA >> prepareDropExecutionOf: aCommand
	aCommand prepareExecutionInSpecialDropContextA: self
]]]


To activate commands with drag and drop use ==CmdDragAndDropCommandActivator==. For example:

[[[
MoveMethodToClassCommand class >> methodBrowserDragAndDropActivator
  <commandActivator>
  ^CmdDragAndDropCommandActivator for: MethodBrowserContext toDropIn: ClassBrowserContext
]]]

And supporting methods would be:

[[[
MoveMethodToClassCommand >> prepareExecutionInDragContext: aToolContext
  super prepareExecutionInDragContext: aToolContext.
  methods := aToolContext selectedMethods

MoveMethodToClassCommand >> prepareExecutionInDropContext: aToolContext
    super prepareExecutionInDropContext: aToolContext.
    targetClass := aToolContext selectedClass
]]]

!!! Conclusion
